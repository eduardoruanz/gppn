//! Combined NetworkBehaviour for the GPPN node.
//!
//! This merges multiple libp2p protocols into a single behaviour:
//! - **GossipSub**: For broadcasting payment messages to the network.
//! - **Kademlia**: For distributed peer/route discovery (DHT).
//! - **mDNS**: For local network peer discovery.
//! - **Identify**: For exchanging peer identity information.
//! - **Request-Response**: For direct peer-to-peer messaging (route requests, etc.).

use libp2p::identity::Keypair;
use libp2p::kad::store::MemoryStore;
use libp2p::swarm::NetworkBehaviour;
use libp2p::{gossipsub, identify, kad, mdns, request_response, PeerId, StreamProtocol};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::time::Duration;

use crate::error::NetworkError;
use crate::protocol::{GppnRequest, GppnResponse, GPPN_PROTOCOL};

/// The combined network behaviour for a GPPN node.
///
/// Uses the `#[derive(NetworkBehaviour)]` macro from libp2p to compose
/// multiple sub-behaviours into a single aggregate behaviour.
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "GppnBehaviourEvent")]
pub struct GppnBehaviour {
    /// GossipSub for broadcasting payment messages.
    pub gossipsub: gossipsub::Behaviour,
    /// Kademlia DHT for peer and route discovery.
    pub kademlia: kad::Behaviour<MemoryStore>,
    /// mDNS for local network peer discovery.
    pub mdns: mdns::tokio::Behaviour,
    /// Identify protocol for exchanging peer metadata.
    pub identify: identify::Behaviour,
    /// Request-response for direct GPPN messaging using CBOR codec.
    pub request_response: request_response::cbor::Behaviour<GppnRequest, GppnResponse>,
}

/// Events emitted by the combined GPPN behaviour.
///
/// This enum is auto-generated by the `#[derive(NetworkBehaviour)]` macro,
/// wrapping each sub-behaviour's event type.
#[derive(Debug)]
pub enum GppnBehaviourEvent {
    /// Event from GossipSub.
    Gossipsub(gossipsub::Event),
    /// Event from Kademlia.
    Kademlia(kad::Event),
    /// Event from mDNS.
    Mdns(mdns::Event),
    /// Event from Identify.
    Identify(identify::Event),
    /// Event from Request-Response.
    RequestResponse(request_response::Event<GppnRequest, GppnResponse>),
}

impl From<gossipsub::Event> for GppnBehaviourEvent {
    fn from(event: gossipsub::Event) -> Self {
        GppnBehaviourEvent::Gossipsub(event)
    }
}

impl From<kad::Event> for GppnBehaviourEvent {
    fn from(event: kad::Event) -> Self {
        GppnBehaviourEvent::Kademlia(event)
    }
}

impl From<mdns::Event> for GppnBehaviourEvent {
    fn from(event: mdns::Event) -> Self {
        GppnBehaviourEvent::Mdns(event)
    }
}

impl From<identify::Event> for GppnBehaviourEvent {
    fn from(event: identify::Event) -> Self {
        GppnBehaviourEvent::Identify(event)
    }
}

impl From<request_response::Event<GppnRequest, GppnResponse>> for GppnBehaviourEvent {
    fn from(event: request_response::Event<GppnRequest, GppnResponse>) -> Self {
        GppnBehaviourEvent::RequestResponse(event)
    }
}

impl GppnBehaviour {
    /// Create a new combined GPPN behaviour from a keypair.
    pub fn new(keypair: &Keypair) -> Result<Self, NetworkError> {
        let local_peer_id = PeerId::from(keypair.public());

        // --- GossipSub ---
        let gossipsub = Self::build_gossipsub(keypair)?;

        // --- Kademlia ---
        let kademlia = Self::build_kademlia(local_peer_id);

        // --- mDNS ---
        let mdns = mdns::tokio::Behaviour::new(
            mdns::Config::default(),
            local_peer_id,
        )
        .map_err(|e| NetworkError::Transport(format!("mDNS init failed: {}", e)))?;

        // --- Identify ---
        let identify = identify::Behaviour::new(identify::Config::new(
            "/gppn/id/1.0.0".into(),
            keypair.public(),
        ));

        // --- Request-Response (CBOR codec) ---
        let request_response = request_response::cbor::Behaviour::new(
            [(GPPN_PROTOCOL, request_response::ProtocolSupport::Full)],
            request_response::Config::default(),
        );

        Ok(Self {
            gossipsub,
            kademlia,
            mdns,
            identify,
            request_response,
        })
    }

    /// Build the GossipSub behaviour with GPPN-specific configuration.
    fn build_gossipsub(keypair: &Keypair) -> Result<gossipsub::Behaviour, NetworkError> {
        // Use a content-based message ID to prevent duplicates.
        let message_id_fn = |message: &gossipsub::Message| {
            let mut hasher = DefaultHasher::new();
            message.data.hash(&mut hasher);
            if let Some(ref source) = message.source {
                source.hash(&mut hasher);
            }
            gossipsub::MessageId::from(hasher.finish().to_string())
        };

        let config = gossipsub::ConfigBuilder::default()
            .heartbeat_interval(Duration::from_secs(10))
            .validation_mode(gossipsub::ValidationMode::Strict)
            .message_id_fn(message_id_fn)
            .max_transmit_size(1024 * 1024) // 1 MiB max message size
            .build()
            .map_err(|e| NetworkError::Gossipsub(format!("config error: {}", e)))?;

        gossipsub::Behaviour::new(
            gossipsub::MessageAuthenticity::Signed(keypair.clone()),
            config,
        )
        .map_err(|e| NetworkError::Gossipsub(format!("behaviour init failed: {}", e)))
    }

    /// Build the Kademlia DHT behaviour.
    fn build_kademlia(local_peer_id: PeerId) -> kad::Behaviour<MemoryStore> {
        let store = MemoryStore::new(local_peer_id);
        let mut config = kad::Config::new(StreamProtocol::new("/gppn/kad/1.0.0"));
        config.set_query_timeout(Duration::from_secs(60));
        kad::Behaviour::with_config(local_peer_id, store, config)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_behaviour_creation() {
        let keypair = Keypair::generate_ed25519();
        let behaviour = GppnBehaviour::new(&keypair);
        assert!(behaviour.is_ok());
    }

    #[test]
    fn test_behaviour_has_gossipsub() {
        let keypair = Keypair::generate_ed25519();
        let behaviour = GppnBehaviour::new(&keypair).expect("behaviour creation failed");
        // Verify gossipsub is accessible
        let _gossipsub = &behaviour.gossipsub;
    }

    #[test]
    fn test_behaviour_has_kademlia() {
        let keypair = Keypair::generate_ed25519();
        let behaviour = GppnBehaviour::new(&keypair).expect("behaviour creation failed");
        let _kademlia = &behaviour.kademlia;
    }

    #[test]
    fn test_behaviour_has_mdns() {
        let keypair = Keypair::generate_ed25519();
        let behaviour = GppnBehaviour::new(&keypair).expect("behaviour creation failed");
        let _mdns = &behaviour.mdns;
    }

    #[test]
    fn test_behaviour_has_identify() {
        let keypair = Keypair::generate_ed25519();
        let behaviour = GppnBehaviour::new(&keypair).expect("behaviour creation failed");
        let _identify = &behaviour.identify;
    }

    #[test]
    fn test_behaviour_has_request_response() {
        let keypair = Keypair::generate_ed25519();
        let behaviour = GppnBehaviour::new(&keypair).expect("behaviour creation failed");
        let _rr = &behaviour.request_response;
    }

    #[test]
    fn test_build_gossipsub_directly() {
        let keypair = Keypair::generate_ed25519();
        let result = GppnBehaviour::build_gossipsub(&keypair);
        assert!(result.is_ok());
    }

    #[test]
    fn test_build_kademlia_directly() {
        let peer_id = PeerId::random();
        let _kad = GppnBehaviour::build_kademlia(peer_id);
        // Just verify it doesn't panic
    }

    #[test]
    fn test_event_from_conversions() {
        // Verify the From implementations compile correctly.
        // We can't easily construct inner events, but we can verify the types compile.
        fn _assert_from_gossipsub(e: gossipsub::Event) -> GppnBehaviourEvent {
            e.into()
        }
        fn _assert_from_kad(e: kad::Event) -> GppnBehaviourEvent {
            e.into()
        }
        fn _assert_from_mdns(e: mdns::Event) -> GppnBehaviourEvent {
            e.into()
        }
        fn _assert_from_identify(e: identify::Event) -> GppnBehaviourEvent {
            e.into()
        }
    }
}
